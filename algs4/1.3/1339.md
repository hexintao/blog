#### 1.3.37 题目：Josephus 问题。N 个身陷绝境的任一致同意通过以下方式减少生存人数。围坐成一圈，位置记为 0 到 N-1并从第一个人开始报数，报到 M 的人会被杀死，直到最后一个人留下来。编写一个 Queue 的用例 Josephus，从命令行接受 N 和 M 并打印出人们被杀死的顺序。例如：
``` python
Josephus 7 2
1 3 5 0 4 2 6
```

解答：
先初始化 N 个人的序号并装入队列，最后只会留下一个人，所以只要队列的 size 大于 1 就循环，循环的部分就是报数。只要不到 M 就一直重复出队再入队的操作，到了 M 就只出队不入队，并打印，代表这个序号被杀死。

``` python
def Josephus(self, m:int, n:int):
    if n < 1:
        print('n is illegal')
        return
    q = Queue()
    for i in range(0, m):
        q.enqueue(i)
    while q.size() > 1:
        j = 1
        while j < n:
            q.enqueue(q.dequeue())
            j += 1
        res = q.dequeue()
        print(f'{res} ', end='')
    print(q.dequeue())
    print('')
```

#### 1.3.38 题目：删除第 k 个元素。需要支持的 API：
* `GeneralizedQueue()`
* `boolean isEmpty()`
* `void insert(Item x)`
* `Iterm delete(int k)`

解答：

1. 数组实现的形式。注意点有：
	* 按照固定顺序插入即可查到最早插入的第 k 个元素，例如一直在数组后边追加元素，这样第k个下标的元素就是目标元素
	* 使用可变数组的思路，在 `insert` 操作的时候，检查数组的长度是否已经增长到了当前数组支持的最大长度，如果到了就翻倍数组的长度。同理在 `delete` 时需要缩小数组的长度

2. 链表的实现形式。
	* 一直在链表的尾结点插入新的元素
	* `delete` 操作即删除第 k 个结点

#### 1.3.39 题目：环形缓冲区。环形队列，定长为 N 的先进先出的数据结构。当缓冲区为空时，消费者会在数据存入缓冲区以前等待；当缓冲区满时，生产者会等待将数据存入缓冲区。为 RingBuffer 设计一份 API 并用（回环）数组将其实现。

解答：

环形缓冲区的优点：

* 写入数据不要求起始位置，随意从哪开始都可以
* 删除数据之后剩余元素不需要移动

设计 API 如下：

* `void enqueue(Item item)`
* `Item dequeue()`
* `boolean isEmpty()`
* `boolean isFull()`
* `int size()`

实现思路：

一开始犯了一个错误，数组没有用0或者其他元素填充，后边写入的时候插入，读取的时候删除，导致序号错乱。在 `RingBuffer` 初始化指定最大容量的时候，用标志元素把数组也初始化了即可，后边存或者取直接修改对应的元素即可，不要影响数组的长度。

`RingBuffer` 就是固定长度，所以优先可以考虑用数组实现。既有存储又有读取，内部可以使用两个局部变量存储写入和读取的位置。回环可以通过判断指针是否超过数组长度，超过就重新从0开始计即可。


``` python
class RingBuffer:
    _first = 0
    _last = 0
    _N = 0
    _list = list()
    _maxLen = 1

    def __init__(self, maxLength):
        if maxLength < 1:
            print('maxLength is illegal')
            return 
        super().__init__()
        self._list = [0 for i in range(0,maxLength)]
        self._maxLen = maxLength

    def enqueue(self, item):
        if item == None:
            print('item should not be None')
            return
        if self.isFull():
            print('RingBuffer is full!')
            return
        self._list[self._first] = item
        self._first += 1
        if self._first >= self._maxLen:
            # reset _first
            self._first = 0
        self._N += 1
            
    
    def dequeue(self):
        if self.isEmpty():
            print('RingBuffer is empty!')
            return
        res = self._list[self._last]
        # reset value
        self._list[self._last] = 0
        self._last += 1
        if self._last >= self._maxLen:
            # reset _last
            self._last = 0
        self._N -= 1
        return res

    def isEmpty(self):
        return self._N == 0
    def isFull(self):
        return self._N >= self._maxLen
    def size(self):
        return self._N
```

测试用例：

``` python
rb = RingBuffer(5)
rb.enqueue(9)
rb.enqueue(8)
rb.enqueue(7)
rb.enqueue(6)
rb.enqueue(5)
rb.enqueue(4)
print(rb.dequeue())
print(rb.dequeue())
print(rb.dequeue())
rb.enqueue(1)
rb.enqueue(2)
rb.enqueue(3)
rb.enqueue(4)
print(rb.dequeue())
print(rb.dequeue())
print(rb.dequeue())
print(rb.dequeue())
print(rb.dequeue())
print(rb.dequeue())
```

输出：

```
RingBuffer is full!
9
8
7
RingBuffer is full!
6
5
1
2
3
```